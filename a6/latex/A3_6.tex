\documentclass[11pt]{scrartcl}

\usepackage[top=2cm]{geometry}
\usepackage{url,hyperref}

\title{
  \textbf{\large Database Tuning -- Assignment 6}\\
  Concurrency Tuning
}

\author{
 Group Name A3\\
 \large Platzer Hugo, 1421579 \\
 \large Strohmeier Mario, 1422959
}

\begin{document}

\maketitle

\section{Description of Setup}
All queries were run from the computer room of the facility on the 'biber' server.

Before each run, the Accounts (account, balance) table is deleted and refilled
by a separate program with the appropriate values.
The ExecutorService class is used to run Transaction threads in parallel, it 
also allows to set a limit for maximum concurrent threads.

Every Transaction thread first creates its own Connection, disables auto-commit (this allows
to build a transaction that consists of multiple statements / queries
, sets the isolation level,
then tries to execute all the statements in the transaction and commit. If this fails, i.e. a SQLException
is generated, it is assumed that the query failed because of serialization problems. Then a rollback is issued
and the transaction tried again from the first statment. This is repeated until the transaction commits.

The main thread waits until all Transaction threads finished execution. Time is measured between
starting the first thread and all of them having completed.

\section*{Task 1}

\subsection*{Read Committed}

Throughput and correctness for solution (a) with serialization level
{\tt\small READ COMMITTED}.

\bigskip

\begin{tabular}{c|c|c}
  \#Concurrent Transactions & Throughput [transactions/sec] & Correctness
  \\\hline
  1 & 26.5726283669 & 1\\
  2 & 53.4700737645 & 0.48\\
  3 & 75.7531079884 & 0.72\\
  4 & 99.2625789954 & 0.46\\
  5 & 118.1106125469 & 0.53\\    
\end{tabular}

\medskip

\subsection*{Serializable}

Throughput and correctness for solution (a) with serialization level
{\tt\small SERIALIZABLE}.

\bigskip

\begin{tabular}{c|c|c}
  \#Concurrent Transactions & Throughput [transactions/sec] & Correctness
  \\\hline
  1 & 24.7294470028 & 1\\
  2 & 45.6853128929 & 1\\
  3 & 48.6842814189 & 1\\
  4 & 47.9781026020 & 1\\
  5 & 47.6115343148 & 1\\    
\end{tabular}

\medskip

\section*{Task 2}

\subsection*{Read Committed}

Throughput and correctness for solution (b) with serialization level
{\tt\small READ COMMITTED}.

\bigskip

\begin{tabular}{c|c|c}
  \#Concurrent Transactions & Throughput [transactions/sec] & Correctness
  \\\hline
  1 & 34.0279361222 & 1\\
  2 & 66.0766814575 & 1\\
  3 & 94.8581941331 & 1\\
  4 & 118.0431697612 & 1\\
  5 & 143.2180611689 & 1\\    
\end{tabular}

\medskip

\subsection*{Serializable}

Throughput and correctness for solution (b) with serialization level
{\tt\small SERIALIZABLE}.

\bigskip

\begin{tabular}{c|c|c}
  \#Concurrent Transactions & Throughput [transactions/sec] & Correctness
  \\\hline
  1 & 30.5110090678 & 1\\
  2 & 53.9302668921 & 1\\
  3 & 60.1654029956 & 1\\
  4 & 59.7850511944 & 1\\
  5 & 59.3435098820 & 1\\    
\end{tabular}

\medskip

\section*{Task 3: Discussion}

Discuss the outcome and explain the difference between the isolation
levels in PostgreSQL with respect to your experiment.

Explain {\bf with your own words} how PostgreSQL deals with updates in
the different isolation levels, within a transaction and within a
single SQL command. Explicitly explain why you got the experimental
results of Task~1 and Task~2.

\subsection*{Task 1}

\subsubsection*{}
For isolation level {\tt\small READ COMMITTED}, it can happen that
after the third statement is executed (reading company account balance) and
before the fourth statement is executed (writing company account balance) another
thread commits a transaction writing the decremented balance. The first thread
then has an outdated account balance; after it writes the decremented balance, only
one of the two decrements is stored. This leads to the company balance not being
completely decremented after all transactions finished. This isolation level however
provides an almost linear performance gain from concurrent transactions.

\subsubsection*{}
Isolation level {\tt\small SERIALIZABLE} guarantees all parallel transactions
have the same effect as if they were run in series. This implies a perfect correctness
score, however the drawbacks of non-tuned locking are also visible: The speedup of concurrent
transactions is far from optimal, more than 3 concurrent threads do not help throughput.

\subsection*{Task 2}

\subsubsection*{}
For isolation level {\tt\small READ COMMITTED}, an {\tt\small UPDATE}
statement acquires an exclusive lock on the rows it should change (Account number 0
in this case) before applying changes.
This makes the decrement {\tt\small balance = balance - 1} atomic since it
prevents other transactions from writing their balance value while the decrement
is in progress.
Also no potentially stale data is stored during a transaction (like company balance
in the first task).

\subsubsection*{}
Isolation level {\tt\small SERIALIZABLE} guarantees all parallel transactions
have the same effect as if they were run in series. This implies a perfect correctness
score, however the drawbacks of non-tuned 

\subsubsection*{}
As for the first transaction, {\tt\small SERIALIZABLE} also provides correctness,
however the locking limits performance in similar fashion. {\tt\small SERIALIZABLE}
does not provide any benefit for this kind of transaction.

\bigskip

\noindent Time in hours per person: {\bf 4}

\bigskip

\begin{center}
  \begin{tabular}{c}
    \hline
    {\bf Important:} Reference your information sources!
    \\\hline
  \end{tabular}
\end{center}

\end{document}
